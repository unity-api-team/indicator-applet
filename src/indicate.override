/*
Python bindings for libindicate.

Copyright 2009 Canonical Ltd.

Authors:
    Eitan Isaacson <eitan@ascender.com>

This program is free software: you can redistribute it and/or modify it 
under the terms of either or both of the following licenses:

1) the GNU Lesser General Public License version 3, as published by the 
Free Software Foundation; and/or
2) the GNU Lesser General Public License version 2.1, as published by 
the Free Software Foundation.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranties of 
MERCHANTABILITY, SATISFACTORY QUALITY or FITNESS FOR A PARTICULAR 
PURPOSE.  See the applicable version of the GNU Lesser General Public 
License for more details.

You should have received a copy of both the GNU Lesser General Public 
License version 3 and version 2.1 along with this program.  If not, see 
<http://www.gnu.org/licenses/>
*/
%%
headers
#include <Python.h>
#include <libindicate/indicator.h>
#include <libindicate/indicator-message.h>
#include <libindicate/listener.h>
#include <libindicate/server.h>
#include <libindicate/interests.h>
#include <libindicate/indicate-enum-types.h>
#include <libindicate-gtk/indicator.h>
#include <libindicate-gtk/listener.h>
#include <glib.h>
#include "pygobject.h"
#include "pyglib.h"

typedef PyObject* (*to_pyobject_func) (gpointer data);

typedef struct
{
		PyGObject       *listener;
		PyObject        *callback;
        to_pyobject_func pyobject_convert;
		PyObject        *user_data;        
} ListenerPropertyCbData;

static void
_listener_get_property_cb(IndicateListener * listener, 
						  IndicateListenerServer * server, 
						  IndicateListenerIndicator * indicator, 
						  gchar * property, gpointer propertydata, 
						  ListenerPropertyCbData *data)
{
        PyGILState_STATE state;
        PyObject *args, *rv, *pyserver, *pyindicator, *pypropertydata = NULL;

        state = pyg_gil_state_ensure();

        pypropertydata = data->pyobject_convert(propertydata);

        pyserver = pyg_pointer_new (INDICATE_TYPE_LISTENER_SERVER, server);
        pyindicator = pyg_pointer_new (INDICATE_TYPE_LISTENER_INDICATOR, indicator);

        if (data->user_data == Py_None)
        {
                args = Py_BuildValue("OOOsO", data->listener, 
                                     pyserver, 
                                     pyindicator,
                                     property,
                                     pypropertydata);
        }
        else
        {
                args = Py_BuildValue("OOOsOO", data->listener, 
                                     pyserver, 
                                     pyindicator,
                                     property,
                                     pypropertydata,
                                     data->user_data);
        }

        Py_DECREF(data->user_data);

        rv = PyEval_CallObject(data->callback, args);

        if (rv == NULL)
                PyErr_Print();
        else
                Py_DECREF(rv);

        Py_DECREF(args);
        Py_DECREF(data->callback);
        g_free(data);

        pyg_gil_state_release(state);
}

static void
_listener_get_server_property_cb(IndicateListener * listener, 
                                 IndicateListenerServer * server, 
                                 gchar *value,
                                 ListenerPropertyCbData *data)
{
		PyGILState_STATE state;
		PyObject *args, *rv, *pyserver;

        pyserver = pyg_pointer_new (INDICATE_TYPE_LISTENER_SERVER, server);

		state = pyg_gil_state_ensure();

		if (data->user_data == Py_None)
		{
				args = Py_BuildValue("OOs", data->listener, 
									 pyserver, 
									 value);
		}
		else
		{
				args = Py_BuildValue("OOsO", data->listener, 
									 pyserver, 
									 value,
									 data->user_data);
		}

		Py_DECREF(data->user_data);

		rv = PyEval_CallObject(data->callback, args);

		if (rv == NULL)
				PyErr_Print();
		else
				Py_DECREF(rv);

		Py_DECREF(args);
		Py_DECREF(data->callback);
		g_free(data);

		pyg_gil_state_release(state);
}

void
_indicate_add_constants(PyObject *module, const gchar *strip_prefix)
{
#ifdef VERSION
        PyModule_AddStringConstant(module, "__version__", VERSION);
#endif
        pyg_enum_add(module, "Interests", 
                     strip_prefix, INDICATE_TYPE_INTERESTS);
        
        if (PyErr_Occurred())
                PyErr_Print();
}
%%
modulename indicate
%%
import gobject.GObject as PyGObject_Type
import gtk.gdk.Pixbuf as PyGdkPixbuf_Type
%%
ignore
  indicate_listener_get_property
  indicate_listener_get_property_time
  indicate_listener_get_property_icon
  indicate_indicator_get_type
  indicate_indicator_message_get_type
  indicate_listener_get_type
  indicate_server_get_type
  indicate_interests_get_type
%%
override indicate_indicator_set_property_time args
static PyObject *
_wrap_indicate_indicator_set_property_time(PyGObject *self, PyObject *args)
{
		double time;
		gchar *key;
		GTimeVal g_time, *g_timep;

		if (!PyArg_ParseTuple(args, "sd:Indicator.set_property_time", 
							  &key, &time))
		{
				return NULL;
		}

		if (time > 0.0) {
				g_time.tv_sec = (glong) time;
				g_time.tv_usec = (glong)((time - g_time.tv_sec)
										 * G_USEC_PER_SEC);
				g_timep = &g_time;
		} else if (time == 0.0) {
				g_timep = NULL;
		} else {
				PyErr_SetString(PyExc_ValueError, "time must be >= 0.0");
				return NULL;
		}

		indicate_indicator_set_property_time(INDICATE_INDICATOR(self->obj), 
											 key, g_timep);

		Py_INCREF(Py_None);
		return Py_None;
}
%%
define IndicateListener.get_indicator_property kwargs
static PyObject *
_convert_string_to_pyobject(gpointer data)
{
        return PyString_FromString((gchar *)data);
}

static PyObject *
_wrap_indicate_listener_get_indicator_property(PyGObject *self, 
											   PyObject *args,
											   PyObject *kwargs)
{
		static char *kwlist[] = { "server", "indicator", "property", "callback",
								  "user_data", NULL };
		ListenerPropertyCbData *listener_property_cb_data;
		gchar *property;
        PyGObject *server, *indicator;
		PyGILState_STATE state;
		PyObject *callback, *user_data = Py_None;
		size_t len;

		state = pyg_gil_state_ensure();

		len = PyTuple_Size(args);

		if (len < 4)
		{
				PyErr_SetString(PyExc_TypeError,
								"IndicateListener.get_property requires at least "
								"3 arguments");
				return NULL;
		}

		if (!PyArg_ParseTupleAndKeywords(args, kwargs,
										 "OOsO|O:IndicateListener.get_property",
										 kwlist,
										 &server, &indicator, &property, &callback, &user_data))
		{
				return NULL;
		}

		if (!PyCallable_Check(callback))
		{
				PyErr_SetString(PyExc_TypeError, "fourth argument must be callable");
				return NULL;
		}

		listener_property_cb_data = g_new0(ListenerPropertyCbData, 1);
		listener_property_cb_data->callback = callback;
		listener_property_cb_data->user_data = user_data;
		listener_property_cb_data->listener = self;
		listener_property_cb_data->pyobject_convert = _convert_string_to_pyobject;

		Py_INCREF(callback);
		Py_INCREF(user_data);

		indicate_listener_get_property(INDICATE_LISTENER(self->obj),
									   (IndicateListenerServer *)server->obj, 
									   (IndicateListenerIndicator *)indicator->obj,
									   property,
									   (indicate_listener_get_property_cb)_listener_get_property_cb,
									   listener_property_cb_data);

		Py_INCREF(Py_None);
		pyg_gil_state_release(state);
		return Py_None;
}
%%
define IndicateListener.get_indicator_property_icon kwargs
static PyObject *
_convert_pixbuf_to_pyobject(gpointer data)
{
        return pygobject_new(data);
}

static PyObject *
_wrap_indicate_listener_get_indicator_property_icon(PyGObject *self, 
                                                    PyObject *args,
                                                    PyObject *kwargs)
{
		static char *kwlist[] = { "server", "indicator", "property", "callback",
								  "user_data", NULL };
		ListenerPropertyCbData *listener_property_cb_data;
		gchar *property;
        PyGObject *server, *indicator;
		PyGILState_STATE state;
		PyObject *callback, *user_data = Py_None;
		size_t len;

		state = pyg_gil_state_ensure();

		len = PyTuple_Size(args);

		if (len < 4)
		{
				PyErr_SetString(PyExc_TypeError,
								"IndicateListener.get_property requires at least "
								"3 arguments");
				return NULL;
		}

		if (!PyArg_ParseTupleAndKeywords(args, kwargs,
										 "OOsO|O:IndicateListener.get_property",
										 kwlist,
										 &server, &indicator, &property, &callback, &user_data))
		{
				return NULL;
		}

		if (!PyCallable_Check(callback))
		{
				PyErr_SetString(PyExc_TypeError, "fourth argument must be callable");
				return NULL;
		}

		listener_property_cb_data = g_new0(ListenerPropertyCbData, 1);
		listener_property_cb_data->callback = callback;
		listener_property_cb_data->user_data = user_data;
		listener_property_cb_data->listener = self;
		listener_property_cb_data->pyobject_convert = _convert_pixbuf_to_pyobject;

		Py_INCREF(callback);
		Py_INCREF(user_data);

		indicate_listener_get_property_icon(
				INDICATE_LISTENER(self->obj),
				(IndicateListenerServer *)server->obj, 
				(IndicateListenerIndicator *)indicator->obj,
				property,
				(indicate_listener_get_property_icon_cb)_listener_get_property_cb,
				listener_property_cb_data);

		Py_INCREF(Py_None);
		pyg_gil_state_release(state);
		return Py_None;
}
%%
define IndicateListener.get_indicator_property_time kwargs
PyObject *
_convert_time_to_pyobject(gpointer data)
{
        GTimeVal *time = data;
        return pyglib_float_from_timeval(*time);
}

static PyObject *
_wrap_indicate_listener_get_indicator_property_time(PyGObject *self, 
													PyObject *args,
													PyObject *kwargs)
{
		static char *kwlist[] = { "server", "indicator", "property", "callback",
								  "user_data", NULL };
		ListenerPropertyCbData *listener_property_cb_data;
		gchar *property;
        PyGObject *server, *indicator;
		PyGILState_STATE state;
		PyObject *callback, *user_data = Py_None;
		size_t len;

		state = pyg_gil_state_ensure();

		len = PyTuple_Size(args);

		if (len < 4)
		{
				PyErr_SetString(PyExc_TypeError,
								"IndicateListener.get_property requires at least "
								"3 arguments");
				return NULL;
		}

		if (!PyArg_ParseTupleAndKeywords(args, kwargs,
										 "OOsO|O:IndicateListener.get_property",
										 kwlist,
										 &server, &indicator, &property, &callback, &user_data))
		{
				return NULL;
		}

		if (!PyCallable_Check(callback))
		{
				PyErr_SetString(PyExc_TypeError, "fourth argument must be callable");
				return NULL;
		}

		listener_property_cb_data = g_new0(ListenerPropertyCbData, 1);
		listener_property_cb_data->callback = callback;
		listener_property_cb_data->user_data = user_data;
		listener_property_cb_data->listener = self;
		listener_property_cb_data->pyobject_convert = _convert_time_to_pyobject;

		Py_INCREF(callback);
		Py_INCREF(user_data);

		indicate_listener_get_property_time(INDICATE_LISTENER(self->obj),
											(IndicateListenerServer *)server->obj, 
											(IndicateListenerIndicator *)indicator->obj,
											property,
											(indicate_listener_get_property_time_cb)_listener_get_property_cb,
											listener_property_cb_data);

		Py_INCREF(Py_None);
		pyg_gil_state_release(state);
		return Py_None;
}
%%
override indicate_listener_server_get_desktop kwargs
static PyObject *
_wrap_indicate_listener_server_get_desktop(PyGObject *self, 
										   PyObject *args,
										   PyObject *kwargs)
{
		static char *kwlist[] = { "server", "callback", "user_data", NULL };
		ListenerPropertyCbData *listener_property_cb_data;
		PyGObject *server;
		PyGILState_STATE state;
		PyObject *callback, *user_data = Py_None;
		size_t len;

		state = pyg_gil_state_ensure();

		len = PyTuple_Size(args);

		if (len < 2)
		{
				PyErr_SetString(PyExc_TypeError,
								"IndicateListener.get_property requires at least "
								"3 arguments");
				return NULL;
		}

		if (!PyArg_ParseTupleAndKeywords(args, kwargs,
										 "OO|O:IndicateListener.get_property",
										 kwlist,
										 &server, &callback, &user_data))
		{
				return NULL;
		}

		if (!PyCallable_Check(callback))
		{
				PyErr_SetString(PyExc_TypeError, "second argument must be callable");
				return NULL;
		}

		listener_property_cb_data = g_new0(ListenerPropertyCbData, 1);
		listener_property_cb_data->callback = callback;
		listener_property_cb_data->user_data = user_data;
		listener_property_cb_data->listener = self;

		Py_INCREF(callback);
		Py_INCREF(user_data);

		indicate_listener_server_get_desktop(
                INDICATE_LISTENER(self->obj),
                (IndicateListenerServer *)server->obj, 
                (indicate_listener_get_server_property_cb)_listener_get_server_property_cb,
                listener_property_cb_data);

		Py_INCREF(Py_None);
		pyg_gil_state_release(state);
		return Py_None;
}
%%
override indicate_listener_server_get_type kwargs
static PyObject *
_wrap_indicate_listener_server_get_type(PyGObject *self, 
                                        PyObject *args,
                                        PyObject *kwargs)
{
		static char *kwlist[] = { "server", "callback", "user_data", NULL };
		ListenerPropertyCbData *listener_property_cb_data;
		PyGObject *server;
		PyGILState_STATE state;
		PyObject *callback, *user_data = Py_None;
		size_t len;

		state = pyg_gil_state_ensure();

		len = PyTuple_Size(args);

		if (len < 2)
		{
				PyErr_SetString(PyExc_TypeError,
								"IndicateListener.server_get_type requires at least "
								"3 arguments");
				return NULL;
		}

		if (!PyArg_ParseTupleAndKeywords(args, kwargs,
										 "OO|O:IndicateListener.server_get_type",
										 kwlist,
										 &server, &callback, &user_data))
		{
				return NULL;
		}

		if (!PyCallable_Check(callback))
		{
				PyErr_SetString(PyExc_TypeError, "second argument must be callable");
				return NULL;
		}

		listener_property_cb_data = g_new0(ListenerPropertyCbData, 1);
		listener_property_cb_data->callback = callback;
		listener_property_cb_data->user_data = user_data;
		listener_property_cb_data->listener = self;

		Py_INCREF(callback);
		Py_INCREF(user_data);

		indicate_listener_server_get_type(INDICATE_LISTENER(self->obj),
										  (IndicateListenerServer *)server->obj, 
										  (indicate_listener_get_server_property_cb)_listener_get_server_property_cb,
										  listener_property_cb_data);

		Py_INCREF(Py_None);
		pyg_gil_state_release(state);
		return Py_None;
}
%%
override indicate_indicator_list_properties
static PyObject *
_wrap_indicate_indicator_list_properties(PyGObject *self)
{		
		GPtrArray *property_list;
		PyObject *pyprop_list;
		guint i;

		property_list = \
				indicate_indicator_list_properties(
						INDICATE_INDICATOR(self->obj));

		pyprop_list = PyList_New (property_list->len);

		for (i=0; i < property_list->len; i++) {
				PyList_SET_ITEM(
						pyprop_list, i, 
						PyString_FromString(
								g_ptr_array_index(property_list, i)));
                g_free(g_ptr_array_index(property_list, i));
        }

        g_ptr_array_free (property_list, TRUE);

		return pyprop_list;
}
%%
